{
    "modelData": {
        "filePath": "dlg-graphs/Cimager_040824.graph",
        "fileType": "Graph",
        "shortDescription": "",
        "detailedDescription": "",
        "repoService": "GitHub",
        "repoBranch": "main",
        "repo": "ICRAR/wallaby-hires",
        "eagleVersion": "v6.2.8",
        "eagleCommitHash": "80717598c275f0e9b15a46e15e79383e0434e85f",
        "schemaVersion": "OJS",
        "readonly": true,
        "repositoryUrl": "",
        "commitHash": "",
        "downloadUrl": "",
        "signature": "",
        "lastModifiedName": "",
        "lastModifiedEmail": "",
        "lastModifiedDatetime": 0,
        "numLGNodes": 6
    },
    "nodeDataArray": [
        {
            "category": "ParameterSet",
            "categoryType": "Data",
            "isGroup": false,
            "color": "#2c2c2c",
            "drawOrderHint": 0,
            "key": -1,
            "name": "StaticParset ",
            "description": "A set of parameters, which can be set and modified in EAGLE and thus is part of the graph. Multiple serialisation formats are available.",
            "x": 258.9116047871653,
            "y": 284.59613422959563,
            "radius": 25,
            "collapsed": false,
            "subject": null,
            "expanded": true,
            "repositoryUrl": "https://github.com/ICRAR/daliuge",
            "commitHash": "b11f970",
            "paletteDownloadUrl": "https://raw.githubusercontent.com/ICRAR/EAGLE_test_repo/master/daliuge/daliuge-master.palette",
            "dataHash": "057c6a8ea53a5d04ce07c2e26ef25cfca59504053407289c5309f81cc44556fc",
            "fields": [
                {
                    "name": "Cimager.dataset",
                    "value": "",
                    "defaultValue": "",
                    "description": "Measurement set file name to read from. Usual substitution rules apply if the parameter is a single string. If the parameter is given as a vector of strings all measurement sets given by this vector are effectively concatenated together on-the-fly in the serial case. In the parallel case, the size of the vector is required to be either 1 or the number of nodes - 1, and therefore there is one measurement set per worker node.",
                    "readonly": false,
                    "type": "Object.Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "13e56f15-04b5-4f4f-831a-50a0808b5058",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.Images.Names",
                    "value": "",
                    "defaultValue": "",
                    "description": "List of image names which this imager will produce. If more than one image is given, a superposition is assumed (i.e. visibilities are fitted with a combined effect of two images; two measurement equations are simply added). Parameters of each image defined in this list must be given in the same parset using ImageName.something keywords (with usual prefix). Note, all image names must start with word image (this is how parameters representing images are distinguished from other type of free parameters in ASKAPsoft), otherwise an exception is thrown. Example of valid names are: image.10uJy, image, imagecena.",
                    "readonly": false,
                    "type": "Object.Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "66837904-5a30-4b42-968b-9d82512677f6",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.Images.direction",
                    "value": "",
                    "defaultValue": "",
                    "description": "Direction to the centre of the required image (or tangent point for facets). This vector should contain a 3-element direction quantity containing right ascension, declination and epoch, e.g. [12h30m00.00, -45.00.00.00, J2000]. Note that a casa style of declination delimiters (dots rather than colons) is essential. Only J2000 directions are currently supported.",
                    "readonly": false,
                    "type": "Object.Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "8b463862-229c-41bd-95c2-57c1db0f9817",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.imagetype",
                    "value": "fits",
                    "defaultValue": "casa",
                    "description": "Type of the image handler (determines the format of the images, both which are written to or read from the disk). Either fits or casa can be requested.",
                    "readonly": false,
                    "type": "Select",
                    "precious": false,
                    "options": [
                        "fits",
                        "casa"
                    ],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "21bcc728-d379-44bc-a522-ca5e87b9dc65",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.Images.shape",
                    "value": "[384,384]",
                    "defaultValue": "[384,384]",
                    "description": "Optional parameter to define the default shape for all images. If an individualshapeparameter is specified separately for one of the images, this default value of the shape is overridden. Individualshapeparameters (see below) must be given for all images if this parameter is not defined. Must be a two-element vector. 1.7 * pb FWHM (~1st null) + 2 * max(pb offset)pb FWHM = 1.2*lambda/12",
                    "readonly": false,
                    "type": "Object.Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "9e46e26c-c5a6-4909-8f30-47b790a04755",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.Images.cellsize",
                    "value": "[2arcsec,2arcsec]",
                    "defaultValue": "[2arcsec,2arcsec]",
                    "description": "Optional parameter to define the default pixel (or cell) size for all images. If an individual cell size parameter is specified separately for one of the images, this default value is overridden. Individual cell size parameters (see below) must be given for all images, if this parameter is omitted. If defined, a 2-element quantity string vector is expected, e.g. [6.0arcsec, 6.0arcsec]. (1/max(u,v) / 6 rad)",
                    "readonly": false,
                    "type": "Object.Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "a47c9034-632e-4ec8-ade4-451fcdad368e",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.freqframe",
                    "value": "bary",
                    "defaultValue": "topo",
                    "description": "Frequency frame to work in (the frame is converted when the dataset is read). Either lsrk or topo is supported.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "9434be25-9f02-4eca-9cea-9e7e7bd9e61c",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.Images.writeAtMajorCycle",
                    "value": false,
                    "defaultValue": "false",
                    "description": "If true, the current images are written to disk after each major cycle (.cyclesuffix is added to the name to reflect which major cycle the image corresponds to). By default, the images are only written afterncyclesmajor cycles are completed.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "f0cce962-6fda-49a8-b2fc-8d511c7d9ff4",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.nUVWMachines",
                    "value": 1,
                    "defaultValue": "0",
                    "description": "Size of uvw-machines cache. uvw-machines are used to convert uvw from a given phase centre to a common tangent point. To reduce the cost to set the machine up (calculation of the transformation matrix), a number of these machines is cached. The key to the cache is a pair of two directions: the current phase centre and the tangent centre. If the required pair is within the tolerances of that used to setup one of the machines in the cache, this machine is reused. If none of the cache items matches the least accessed one is replaced by the new machine which is set up with the new pair of directions. The code would work faster if this parameter is set to the number of phase centres encountered during imaging. In non-faceting case, the optimal setting would be the number of synthetic beams times the number of fields. For faceting (btw, the performance gain is quite significant in this case), it should be further multiplied by the number of facets. Direction tolerances are given as a separate parameter.",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "80112171-c2ef-43b3-a136-b144f7e5f082",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.ncycles",
                    "value": 3,
                    "defaultValue": "0",
                    "description": "Number of major cycles (and iterations over the dataset)",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "2c212ce9-ee96-4c00-b243-7d053e32f642",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.snapshotimaging",
                    "value": false,
                    "defaultValue": "false",
                    "description": "If true, snapshot imaging is done. In this mode, a w=au+bv plane is fitted to baseline coordinates and the effective w-term becomes a difference between the actual w-term and the fitted plane. The subtraction of such a plane is equivalent to the coordinate distortion. Therefore, every time the fit is updated, the current dirty and weight images are regridded into a stable frame. How often the new fit is done depends on the w-tolerance parameter, which must be given if the snap-shot imaging is used.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "50dc4afc-d769-4da8-a144-f462061bb22d",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.snapshotimaging.wtolerance",
                    "value": "2600",
                    "defaultValue": "",
                    "description": "Required tolerance on residual w-term for snap-shot imaging (in wavelengths).This parameter must be given if the snap-shot imaging is used. An exception is thrown if the antenna layout is significantly non-coplanar and the required tolerance cannot be achieved by plane fitting.",
                    "readonly": false,
                    "type": "Object.Double",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "ba30936d-a6dc-4a60-8dc2-778fa1c12bbc",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.snapshotimaging.longtrack",
                    "value": true,
                    "defaultValue": "false",
                    "description": "If true the best fit W plane for the snapshot is predicted by advancing the uvw in time and finding that plane which minimises the deviation in the future. Some minutes from the current time. This allows the max deviation to remain within tolerance for almost twice as long as the default scheme. This can have a substantial effect on processing time for long tracks. It should be a factor of two faster.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "f2ecfdc6-ec7b-4e4c-93ec-806799766c60",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.snapshotimaging.clipping",
                    "value": "0.01",
                    "defaultValue": "0",
                    "description": "Optional clipping to avoid edge effects during image reprojection. This parameter represents the fraction of the image size (on each directional axis) which is zeroed (equally from both sides). It should be a non-negative number less than 1. Set it to 0 (default) to avoid any clipping. Applies to all images (image.*, residual.*, weights.*, etc.).",
                    "readonly": false,
                    "type": "Object.Double",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "9e557f59-84d7-48b9-9525-313d13ea6fe7",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder",
                    "value": "WProject",
                    "defaultValue": "Box",
                    "description": "Name of the gridder, further parameters are given bygridder.something. SeeGriddersfor details.",
                    "readonly": false,
                    "type": "Select",
                    "precious": false,
                    "options": [
                        "Box",
                        "SphFunc",
                        "WProject",
                        "MPIWProject",
                        "WStack",
                        "AWProject",
                        "AProjectWStack"
                    ],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "f67cd743-9262-40fc-8f28-adf141df1cd8",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.WProject.wmax",
                    "value": 35000,
                    "defaultValue": "largest w value relative to the tangent of the first image (or the largest residual w when using snapshots)",
                    "description": "Largest allowed absolute value of the w term in wavelengths.  An exception will be thrown if the dataset contains w-term exceeding this value (W scaling error: recommend allowing larger range of w).",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "58986632-abd8-49e0-b5fc-d87a0c5878fb",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.WProject.nwplanes",
                    "value": 257,
                    "defaultValue": "65",
                    "description": "Number of w-planes. Number of w planes must be an odd positive number. For the WProject gridder this scales up the number of convolution functions calculated. For the WStack gridder this is the number of grids maintained. You may (and will) run out of memory for a large number of w planes, especially for the stacking algorithm",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "9d4a84e3-2fde-40d7-b1ef-1cdf3f63e360",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.WProject.oversample",
                    "value": 4,
                    "defaultValue": "8",
                    "description": "Oversampling factor. Convolution functions will be computed for this number of pixels per uv-cell.",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "4953fcc7-4ddc-4716-a487-bb948ae1a340",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.WProject.maxsupport",
                    "value": 1024,
                    "defaultValue": "256",
                    "description": "The largest allowed support size in pixels. The grid used to compute the convolution function (before the support is searched and the appropriate inner part of the grid is extracted) is initialised to have the size equal to the smallest of maxsupport and the image size. WProject uses maxsupport x maxsupport grid at the moment regardless of the image size.",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "842a00d0-49eb-4b1f-916d-8fe510acd753",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.WProject.variablesupport",
                    "value": true,
                    "defaultValue": "false",
                    "description": "If true, the support will be searched separately for each convolution function. This can speed things up considerably, unless costs to search the support dominates. It was also found that when variable support is used, the algorithm is more sensitive to cutoff value. Too high cutoff value has a significant impact on the image quality if the variable support is used.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "c652331e-70be-4263-b10c-c057ff7b7152",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.WProject.offsetsupport",
                    "value": true,
                    "defaultValue": "false",
                    "description": "If true, an offset of the convolution function will be treated separately (the support will be defined by size and offset, which can be non-zero in general). This option reduces the memory footprint and speeds up greeting. It can only be used in conjunction withvariablesupport=true",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "00ebc166-ca64-4b25-b9bc-55e207f81bca",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.WProject.sharecf",
                    "value": true,
                    "defaultValue": "false",
                    "description": "If true, use a (static) cache for the convolution functions in the WProject gridder. This saves both time and memory, especially for large images and spectral line cubes. Tests show no significant changes in continuum imaging but small differences in spectral cubes, it is not clear yet if these are a problem. Feedback welcome",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "4a5173d2-ce12-49c0-8656-6629c0143a62",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver",
                    "value": "Clean",
                    "defaultValue": "",
                    "description": "Name of the solver, further parameters are given bysolver.something. See Solvers for details",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [
                        "Clean",
                        "Dirty"
                    ],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "10810e81-2ddc-4f32-94a3-5c630984c4b7",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.algorithm",
                    "value": "BasisfunctionMFS",
                    "defaultValue": "BasisfunctionMFS",
                    "description": "Valid choices are MultiScale, Basisfunction, Hogbom, MultiScaleMFS and BasisfunctionMFS. Use Hogbom for a single scale, non-MFS case. For the Clean solver, the casacore\u2019sLatticeCleanerused to do the actual work in non-MSMFS case will be set up withCleanEnums::HOGBOMif algorithm is Hogbom and the single scale of 0 will be used.  For the Basisfunction algorithm, a re-implemented and improved version of the CASA MultiScale algorithm is used. BasisfunctionMFS is the optimised algorithm used for most ASKAP processing",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "92a8117d-0bc4-4162-b163-57d922090f93",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.niter",
                    "value": 800,
                    "defaultValue": "100",
                    "description": "Number of minor cycles",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "c47eb589-249a-4aa2-88aa-3d38fe3187cc",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.gain",
                    "value": 0.2,
                    "defaultValue": "0.7",
                    "description": "Loop gain. Fraction of the peak subtracted during one minor cycle.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "6e5dc61a-f787-4dd1-9e04-b3f79261b443",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.scales",
                    "value": "[0,10,30,60]",
                    "defaultValue": "[0,3,10]",
                    "description": "Scales to be solved (defined in pixels). Ignored if algorithm=Hogbom",
                    "readonly": false,
                    "type": "Object.Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "c3d426ad-434e-4f56-817f-d1d7818f5ccc",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.verbose",
                    "value": "False",
                    "defaultValue": "true",
                    "description": "True enables lots of output",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "e5100f11-a2c7-468d-860a-a2e4b6fd701e",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.tolerance",
                    "value": 0.01,
                    "defaultValue": "0.1",
                    "description": "cutoff value given as a fraction of the largest diagonal element. The linear system describing interferometric measurement is inverted approximately, assuming that the matrix is diagonal, i.e. the right-hand side is divided by the appropriate diagonal element (which is a weight). If diagonal is smaller than this tolerance multiplied by the largest diagonal element, the right-hand side instead is either divided by the largest diagonal element to get the result or the result is set to zero. This is controlled byweightcutoffparameter. For images it means that areas with low weight (i.e. a mosaic edge) are not boosted up. In addition to weight truncation, all pixels with the weight below cutoff are normally masked out. Theweightcutoff.cleanparameter allows to assign mask corresponding to weight truncation. This allows S/N-based cleaning to happen, if the peak of S/N is realised outside the nominal field of view.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "7ce14864-505d-414a-aab1-5c6d601c4e94",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.weightcutoff",
                    "value": "zero",
                    "defaultValue": "truncate",
                    "description": "Either zero or truncate. This parameter controls what actually happens for values below cutoff defined by thetoleranceparameter. Ifzerois given, the appropriate values are set to zero. Fortruncate, the values are divided by the largest diagonal.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "ca1a8a08-ab10-44a4-9d7a-0b3bc686c74f",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.weightcutoff.clean",
                    "value": false,
                    "defaultValue": "false",
                    "description": "This parameter defines whether the values below cutoff are masked out or not. By default, the are masked out and so S/N-based clean never finds optima among these values. If this parameter is true, the mask is actually sqrt(tolerance), which corresponds to truncation of the diagonal during normalisation. This potentially allows cleaning to happen, if no peak of the S/N is realised among these values.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "924e91a3-31a9-4ed3-a30d-5191e078f5d4",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.decoupled",
                    "value": true,
                    "defaultValue": "true",
                    "description": "Use decoupled residuals - this improves convergence for large scales, allows the use of a lower percentage threshold.minorcycle and seems to have few drawbacks",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "27d067dd-7367-45c8-a175-fe15d9627727",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.psfwidth",
                    "value": 256,
                    "defaultValue": "0",
                    "description": "Sets the width of the psf patch used in the minor cycle. This decreases memory use and run time by approximately the ratio of pixels in the patch to pixels in the image.",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "6c36e1e7-0230-4bfb-9d5f-3fd832c11819",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.logevery",
                    "value": 48,
                    "defaultValue": "1",
                    "description": "How frequently to log progress in the minor cycle. Every nth iteration is reported (ie. iflogevery=100, every 100th iteration is reported), providing the iteration number, the peak residual, the objective function and the total flux.",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "98fa78d7-3b8b-4adc-a3b4-b9fd51bcfa6d",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.detectdivergence",
                    "value": true,
                    "defaultValue": "true",
                    "description": "Check if the deconvolution is diverging - stop the major cycles if the residuals increase by a factor 2",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "24bb89ca-fe72-4e96-ae66-a59be7f285c0",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.threshold.minorcycle",
                    "value": "[45%, 3.5mJy, 0.5mJy]",
                    "defaultValue": "no threshold",
                    "description": "If defined, the parameter can be either a single string or a vector of 2 or 3 strings. A number without units, or with a percentage sign, is interpreted as a fractional stopping threshold (with respect to the peak residual). An absolute flux given in Jy or related units is interpreted as an absolute threshold. A string like 5.0sigma will set a threshold relative to the noise in the residuals. You can mix fractional and absolute or noise thresholds, but can\u2019t mix absolute and noise ones. An undefined parameter means no minor cycle thresholding is done. A second absolute flux (or noise) threshold can be used to specify a deep clean threshold. During deep cleaning only pixels already in the model are searched to find new components. Setting the deep clean threshold to 0.5 times the noise level generally leaves very few sidelobes visible. Deep clean and noise based threshold are currently only implemented for the BasisFunctionMFS solver",
                    "readonly": false,
                    "type": "Object.Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "3a8e11cf-4443-4914-9a29-12acc8b7ae14",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.threshold.majorcycle",
                    "value": "0.5mJy",
                    "defaultValue": "-1Jy",
                    "description": "The target peak residual. Use negative value to ensure all requested major cycles are done.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "8a240b3e-d1d6-4c53-88ab-7f900736d850",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.preconditioner.GaussianTaper",
                    "value": "[12arcsec, 12arcsec, 0deg]",
                    "defaultValue": "",
                    "description": "A Gaussian taper is applied to the visibilities. The parameter should be either a single string with the FWHM of a circular gaussian taper, or a vector of three strings for an elliptical taper: the major and minor axis FWHM and the position angle. String values may contain units, e.g.[10arcsec,10arcsec,34deg]. If no units are given, radians are assumed.GaussianTapercurrently conflicts with different uv-cell sizes for different images. An exception is thrown if such a condition exists.",
                    "readonly": false,
                    "type": "Object.Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "ce853fad-c6c8-4d7e-bd4c-f234d6565ea5",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.preconditioner.GaussianTaper.isPsfSize",
                    "value": true,
                    "defaultValue": "false",
                    "description": "If true, try to make the final fitted PSF the size given. This uses the restore.beam.cutoff parameter for the fit. A warning will appear in the log if the target PSF size was not achieved.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "d54e9374-674c-4d5c-8b03-7efdb621051a",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.preconditioner.GaussianTaper.tolerance",
                    "value": 0.005,
                    "defaultValue": "0.005",
                    "description": "Specify the fractional tolerance of the fitted beam size when isPsfSize is true, default is 0.5%",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "839b4486-f7d4-4c59-bdfa-e11ad727eaa8",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.preconditioner.preservecf",
                    "value": true,
                    "defaultValue": "false",
                    "description": "Use a modified PSF to generate any preconditioner that is derived from the uv sampling function (e.g.WienerandRobust). This option takes a running mean over an approximate nearest-neighbour sampling function with a box width that is proportional to the support size of the gridding kernels. This enables post-gridding density weighting while preserving the gridding convolutions. Note that this is currently only used with theWienerpreconditioner and theWProjectgridder. The default is normally false, but will be true if preconditioning is used.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "1b4e1531-b5a2-4892-8e36-7c01a3a5e660",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.preconditioner.Wiener.robustness",
                    "value": 0.5,
                    "defaultValue": "0",
                    "description": "The noise power is derived from the given value of robustness to have roughly the same effect as the analogous parameter in Robust (i.e., -2.0 close to uniform weighting, +2.0 close to natural weighting). Note that the Wiener filter must be specified with eithernoisepowerorrobustness.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "eec61cde-ed21-4ca3-b22c-345d0386b856",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.restore",
                    "value": true,
                    "defaultValue": "false",
                    "description": "If true, the image will be restored (by convolving with the given 2D gaussian). This is an additional step to normal imaging, which, by default, ends with just a model image. The restored image is written into a separate image file (with the.restoredsuffix). The convolution is done with the restore solver (see alsoSolvers) which by default reuses the same parameters used to setup the image solver. An additional preconditioning step with alternative parameters can be specified usingrestore.preconditioner.xxx, which results in a second set of restored files (with the.alt.restoredsuffix). The only additional parameter of the restore solver is the shape of the gaussian representing clean beam (or flag to determine the shape). It is given by therestore.beamparameter, which must be present ifrestoreis set to True.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "6bb38592-9b84-4c31-962a-fb6f08444d7f",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.restore.beam",
                    "value": "fit",
                    "defaultValue": "",
                    "description": "Either a single wordfitor a quantity string describing the shape of the clean beam (to convolve the model image with). If quantity is given it must have exactly 3 elements, e.g. [30arcsec, 10arcsec, 40deg]. Otherwise an exception is thrown. This parameter is only used ifrestoreis set to True. If restore.beam=fit, the code will fit a 2D gaussian to the PSF image (first encountered if multiple images are solved for) and use the results of this fit.",
                    "readonly": false,
                    "type": "Object.Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "8e15254f-2dc9-48fe-b583-1b54c626f9a9",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.restore.beam.cutoff",
                    "value": 0.5,
                    "defaultValue": "0.05",
                    "description": "Cutoff for the support search prior to beam fitting, as a fraction of the PSF peak. This parameter is only used ifrestore.beam=fit. The code does fitting on a limited support (to speed things up and to avoid sidelobes influencing the fit). The extent of this support is controlled by this parameter representing the level of the PSF which should be included into support. This value should be above the first sidelobe level for meaningful results.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "e07598d2-4215-4d04-86c1-eef792079bf7",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.MaxUV",
                    "value": 7000,
                    "defaultValue": "0",
                    "description": "Select data based on the uv-distance (in metres). Only visibility points corresponding to uv-distance smaller than the given value (defined in metres) are read from the measurement set. Note, the selection is done without taking frequency information into account.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "f99bf5da-6fc5-406a-b074-4939652ce0b0",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.MinUV",
                    "value": 12,
                    "defaultValue": "0",
                    "description": "Select data based on the uv-distance (in metres). Only visibility points corresponding to uv-distance greater than the given value (defined in metres) are read from the measurement set. Note, the selection is done without taking frequency information into account.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "5f2c6b00-dcae-4a2a-b75a-7ccd710ef152",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.preconditioner.Names",
                    "value": "[Wiener,GaussianTaper]",
                    "defaultValue": "",
                    "description": "List of preconditioners to be applied (in the order they are given in the list). Preconditioners are ASKAPsoft equivalents of visibility weighting (i.e. uniform, robust, natural), which do not require multiple passes over the dataset. Preconditioners can be viewed as operators applied to equation matrix before it is solved. Having the normal matrix as close to the diagonal as possible (a diagonal form is actually assumed during the inversion process) makes the inversion more accurate. By default, no transformation to the normal matrix is done. This is equivalent to the natural weighting. The following preconditioners are currently implemented: Wiener, NormWiener, Robust and GaussianTaper. In addition, the word None is understood as an empty preconditioner which does nothing. Each preconditioner requires a specific set of parameters described in a separate section. These parameters are given after the name of the preconditioner, e.g. preconditioner.Wiener.noisepower (see below)",
                    "readonly": false,
                    "type": "Object.Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "f146e074-67b3-49be-a5c8-7b0792bf609a",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.nchanpercore",
                    "value": 2,
                    "defaultValue": "1",
                    "description": "",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "0ffbf719-f0d5-4dee-aeba-e4a427df226f",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.nwriters",
                    "value": 2,
                    "defaultValue": "1",
                    "description": "The number of output cubes to generate in spectral cube mode.",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "a655d8cc-561d-426b-87fd-8d6edc1debc2",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.singleoutputfile",
                    "value": true,
                    "defaultValue": "false",
                    "description": "Single output cube. Useful in the case of multiple writers.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "2ea32969-f080-42d2-bc37-5f3f8825dbcc",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.Channels",
                    "value": "[4,1]",
                    "defaultValue": "",
                    "description": "Channels to be selected from the measurement set. Syntax is [<number>,<start>]. Defaults to all the channels.",
                    "readonly": false,
                    "type": "Object.Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "b60ad299-62dc-456a-a54d-f7dd0f662d96",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.usetmpfs",
                    "value": false,
                    "defaultValue": "false",
                    "description": "Whether to store the visibilities in shared memory.This will give a performance boost at the expense of memory usage. Better used for processing continuum data.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "5118e3e1-e80e-4bda-88f3-3c501781bb20",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.tmpfs",
                    "value": "/dev/shm",
                    "defaultValue": "/dev/shm",
                    "description": "Location of the shared memory.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "28b3b3cd-c985-4992-aae1-7ed0a65e21a9",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.solutiontype",
                    "value": "MAXBASE",
                    "defaultValue": "MAXBASE",
                    "description": "The type of peak finding algorithm to use in the deconvolution. Choices are MAXCHISQ, MAXTERM0, or MAXBASE.",
                    "readonly": false,
                    "type": "Select",
                    "precious": false,
                    "options": [
                        "MAXBASE",
                        "MAXCHISQ",
                        "MAXTERM0"
                    ],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "bd9fd3fb-aa20-444f-b571-bbf8465675b0",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.restore.beamReference",
                    "value": "mid",
                    "defaultValue": "mid",
                    "description": "The channel to use as the reference for the beam - this channel\u2019s beam is written to the cube header. Values can be an integer indicating the channel number (0-based), or one of \u2018mid\u2019, \u2018first\u2019, or \u2018last\u2019.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "e0b2d3c9-d938-49f8-b188-d7204f009272",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.Images.restFrequency",
                    "value": "HI",
                    "defaultValue": "null",
                    "description": "A string indicating the rest frequency to be written to the image cube header (for the restored, model and residual cubes only). The string can be a quantity string (e.g. 1234.567MHz) or the special string \u2018HI\u2019, which resovles to 1420.405751786 MHz. If not given, no rest frequency is written to the cubes.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "3418fcef-28ac-4745-b969-5e320fb19430",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "data_volume",
                    "value": 5,
                    "defaultValue": "5",
                    "description": "Estimated size of the data contained in this node",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "0cd24989-0087-4966-9832-6a26b5165a2d",
                    "parameterType": "ConstraintParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "group_end",
                    "value": false,
                    "defaultValue": "False",
                    "description": "Is this node the end of a group?",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "54f4402d-7da2-46f9-905b-f9f3d5af6f3d",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "mode",
                    "value": "YANDA",
                    "defaultValue": "YANDA",
                    "description": "Serialisation method.",
                    "readonly": false,
                    "type": "Select",
                    "precious": false,
                    "options": [
                        "YANDA",
                        "ini",
                        "yaml",
                        "json",
                        "toml",
                        "pickle"
                    ],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "e5c03230-fc37-43cd-9b80-82a31b137511",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "config_data",
                    "value": "",
                    "defaultValue": "",
                    "description": "Additional configuration information to be mixed in with the initial data",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "c8ee5d66-b274-4776-9177-686f66ac8b9f",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "dropclass",
                    "value": "dlg.data.drops.parset_drop.ParameterSetDROP",
                    "defaultValue": "dlg.data.drops.parset_drop.ParameterSetDROP",
                    "description": "Drop class",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "cbca5a6f-4a28-4b64-92fb-da3ce4b3d832",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "streaming",
                    "value": false,
                    "defaultValue": "False",
                    "description": "Specifies whether this data component streams input and output data",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "8b26116c-36a9-4b26-a9b3-ef4935a9f5da",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "persist",
                    "value": false,
                    "defaultValue": "False",
                    "description": "Specifies whether this data component contains data that should not be deleted after execution",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "4c3d14ab-724b-4115-af07-967a67ebff0d",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "Config",
                    "value": "",
                    "defaultValue": "",
                    "description": "The output configuration file",
                    "readonly": false,
                    "type": "Object.File",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "58a4503f-a894-4f9c-ab7a-3b14896a8b3b",
                    "parameterType": "ComponentParameter",
                    "usage": "OutputPort"
                }
            ],
            "inputAppFields": [],
            "outputAppFields": [],
            "inputApplicationName": "",
            "inputApplicationType": "None",
            "inputApplicationKey": null,
            "inputApplicationDescription": "",
            "outputApplicationName": "",
            "outputApplicationType": "None",
            "outputApplicationKey": null,
            "outputApplicationDescription": ""
        },
        {
            "category": "PythonApp",
            "categoryType": "Application",
            "isGroup": false,
            "color": "#0059a5",
            "drawOrderHint": 0,
            "key": -2,
            "name": "CopyApp",
            "description": "A simple APP that copies its inputs into its outputs. All inputs are copied into all outputs in the order they were declared in the graph. If an input is a container (e.g. a directory) it copies the content recursively.",
            "x": 458.7610449234037,
            "y": 285.1139937158864,
            "radius": 25,
            "collapsed": false,
            "subject": null,
            "expanded": true,
            "repositoryUrl": "https://github.com/ICRAR/daliuge",
            "commitHash": "b11f970",
            "paletteDownloadUrl": "https://raw.githubusercontent.com/ICRAR/EAGLE_test_repo/master/daliuge/daliuge-master.palette",
            "dataHash": "d3133e45e28a7944c18ee04f5631f49d1707d54764a385d35fc7d51defeeebfe",
            "fields": [
                {
                    "name": "bufsize",
                    "value": 65536,
                    "defaultValue": "65536",
                    "description": "Buffer size",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "8adbfa8e-5bf5-4a2e-ac2d-4f7e95e90210",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "dropclass",
                    "value": "dlg.apps.simple.CopyApp",
                    "defaultValue": "dlg.apps.simple.CopyApp",
                    "description": "Application class",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "f754923d-3fdc-49c5-b6ac-9c6299b7cd0d",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "execution_time",
                    "value": 5,
                    "defaultValue": "5",
                    "description": "Estimated execution time",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "0717d90e-bfbc-4ad9-8806-ef1e8b0d3a1f",
                    "parameterType": "ConstraintParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "num_cpus",
                    "value": 1,
                    "defaultValue": "1",
                    "description": "Number of cores used",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "67c40b0a-f656-4762-9e85-7d53d9732b6b",
                    "parameterType": "ConstraintParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "group_start",
                    "value": false,
                    "defaultValue": "False",
                    "description": "Is this node the start of a group?",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "0bdc8aef-5308-4d84-b1e1-7364ee68d287",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "n_tries",
                    "value": 1,
                    "defaultValue": "1",
                    "description": "Specifies the number of times the 'run' method will be executed before finally giving up",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "b823f939-54c6-4192-ba19-d1d1049e5ec0",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "dummy",
                    "value": "",
                    "defaultValue": "",
                    "description": "Dummy port",
                    "readonly": false,
                    "type": "Object",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "da3f2498-cd24-451f-8336-1724d9300606",
                    "parameterType": "ApplicationArgument",
                    "usage": "InputOutput"
                },
                {
                    "name": "input_parser",
                    "value": "pickle",
                    "defaultValue": "pickle",
                    "description": "Input port parsing technique",
                    "readonly": false,
                    "type": "Select",
                    "precious": false,
                    "options": [
                        "raw",
                        "pickle",
                        "eval",
                        "npy",
                        "path",
                        "dataurl"
                    ],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "b71c2de5-588a-4bac-a9b9-b27c7d868d9e",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "output_parser",
                    "value": "pickle",
                    "defaultValue": "pickle",
                    "description": "Output port parsing technique",
                    "readonly": false,
                    "type": "Select",
                    "precious": false,
                    "options": [
                        "raw",
                        "pickle",
                        "eval",
                        "npy",
                        "path",
                        "dataurl"
                    ],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "932053e3-fef5-434b-8694-0562b643300c",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                }
            ],
            "inputAppFields": [],
            "outputAppFields": [],
            "inputApplicationName": "",
            "inputApplicationType": "None",
            "inputApplicationKey": null,
            "inputApplicationDescription": "",
            "outputApplicationName": "",
            "outputApplicationType": "None",
            "outputApplicationKey": null,
            "outputApplicationDescription": ""
        },
        {
            "category": "File",
            "categoryType": "Data",
            "isGroup": false,
            "color": "#2c2c2c",
            "drawOrderHint": 0,
            "key": -4,
            "name": "File1",
            "description": "A standard file on a filesystem mounted to the deployment machine",
            "x": 634.9778457820286,
            "y": 283.2084097831882,
            "radius": 25,
            "collapsed": false,
            "subject": null,
            "expanded": true,
            "repositoryUrl": "https://github.com/ICRAR/daliuge",
            "commitHash": "b11f970",
            "paletteDownloadUrl": "https://raw.githubusercontent.com/ICRAR/EAGLE_test_repo/master/daliuge/daliuge-master.palette",
            "dataHash": "f40f919804d78c6b8e2674e3089e84fcb9a43bd732aec6bd8e29ddffb724de4a",
            "fields": [
                {
                    "name": "filepath",
                    "value": "",
                    "defaultValue": "",
                    "description": "File path for this file. In many cases this does not need to be specified. If it has a \\/ at the end it will be treated as a directory name and the filename will be generated. If it does not have a \\/, the last part will be treated as a filename. If filepath does not start with \\/ (relative path) then the session directory will be prepended to make the path absolute.\"",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "79ee7c04-93c0-454b-8a3c-97f5f071e5fb",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "check_filepath_exists",
                    "value": false,
                    "defaultValue": "False",
                    "description": "Perform a check to make sure the file path exists before proceeding with the application",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "aa63612b-4c71-4a6f-bb03-bc7d7ccc823e",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "dropclass",
                    "value": "dlg.data.drops.file.FileDROP",
                    "defaultValue": "dlg.data.drops.file.FileDROP",
                    "description": "Drop class",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "75713322-cbef-412d-866d-a88ef8056ec0",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "streaming",
                    "value": false,
                    "defaultValue": "False",
                    "description": "Specifies whether this data component streams input and output data",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "bf352229-f019-4902-817d-9284ff81713d",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "persist",
                    "value": true,
                    "defaultValue": "True",
                    "description": "Specifies whether this data component contains data that should not be deleted after execution",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "315302d2-a427-49a2-836e-71beda92b2e7",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "data_volume",
                    "value": 5,
                    "defaultValue": "5",
                    "description": "Estimated size of the data contained in this node",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "98a5ab3f-93eb-4809-83fe-02e320700b95",
                    "parameterType": "ConstraintParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "group_end",
                    "value": false,
                    "defaultValue": "False",
                    "description": "Is this node the end of a group?",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "ebc597f1-64e7-43a1-b819-9a2aaf75b4ac",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "dummy",
                    "value": "",
                    "defaultValue": "",
                    "description": "Dummy port",
                    "readonly": false,
                    "type": "Object",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "8528f8ab-2dbb-4b4d-87c9-6667e732c13e",
                    "parameterType": "ApplicationArgument",
                    "usage": "InputOutput"
                }
            ],
            "inputAppFields": [],
            "outputAppFields": [],
            "inputApplicationName": "",
            "inputApplicationType": "None",
            "inputApplicationKey": null,
            "inputApplicationDescription": "",
            "outputApplicationName": "",
            "outputApplicationType": "None",
            "outputApplicationKey": null,
            "outputApplicationDescription": ""
        },
        {
            "category": "File",
            "categoryType": "Data",
            "isGroup": false,
            "color": "#2c2c2c",
            "drawOrderHint": 0,
            "key": -6,
            "name": "File2",
            "description": "A standard file on a filesystem mounted to the deployment machine",
            "x": 638.749621145608,
            "y": 465.6139386363128,
            "radius": 25,
            "collapsed": false,
            "subject": null,
            "expanded": true,
            "repositoryUrl": "https://github.com/ICRAR/daliuge",
            "commitHash": "b11f970",
            "paletteDownloadUrl": "https://raw.githubusercontent.com/ICRAR/EAGLE_test_repo/master/daliuge/daliuge-master.palette",
            "dataHash": "f40f919804d78c6b8e2674e3089e84fcb9a43bd732aec6bd8e29ddffb724de4a",
            "fields": [
                {
                    "name": "filepath",
                    "value": "",
                    "defaultValue": "",
                    "description": "File path for this file. In many cases this does not need to be specified. If it has a \\/ at the end it will be treated as a directory name and the filename will be generated. If it does not have a \\/, the last part will be treated as a filename. If filepath does not start with \\/ (relative path) then the session directory will be prepended to make the path absolute.\"",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "d97d1b97-500d-41fb-b6f7-c74aceb2dec9",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "check_filepath_exists",
                    "value": false,
                    "defaultValue": "False",
                    "description": "Perform a check to make sure the file path exists before proceeding with the application",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "15674e78-b4d0-4120-bb5f-6988db46f61c",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "dropclass",
                    "value": "dlg.data.drops.file.FileDROP",
                    "defaultValue": "dlg.data.drops.file.FileDROP",
                    "description": "Drop class",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "c62b7510-8479-4bdd-b077-78f8a40dc907",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "streaming",
                    "value": false,
                    "defaultValue": "False",
                    "description": "Specifies whether this data component streams input and output data",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "e9e02c14-115e-41c8-82a9-fa6a1f66aebc",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "persist",
                    "value": true,
                    "defaultValue": "True",
                    "description": "Specifies whether this data component contains data that should not be deleted after execution",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "d44835c4-979c-447e-9bbf-fe6198c3eebe",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "data_volume",
                    "value": 5,
                    "defaultValue": "5",
                    "description": "Estimated size of the data contained in this node",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "421b324e-72f9-4cf8-b92e-f1d6f28c078c",
                    "parameterType": "ConstraintParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "group_end",
                    "value": false,
                    "defaultValue": "False",
                    "description": "Is this node the end of a group?",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "007a64af-dd70-49b4-ba9f-87d066f0705a",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "dummy",
                    "value": "",
                    "defaultValue": "",
                    "description": "Dummy port",
                    "readonly": false,
                    "type": "Object",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "d02e24bd-4049-4afc-a8cc-0485f19d5373",
                    "parameterType": "ApplicationArgument",
                    "usage": "InputOutput"
                }
            ],
            "inputAppFields": [],
            "outputAppFields": [],
            "inputApplicationName": "",
            "inputApplicationType": "None",
            "inputApplicationKey": null,
            "inputApplicationDescription": "",
            "outputApplicationName": "",
            "outputApplicationType": "None",
            "outputApplicationKey": null,
            "outputApplicationDescription": ""
        },
        {
            "category": "PythonApp",
            "categoryType": "Application",
            "isGroup": false,
            "color": "#0059a5",
            "drawOrderHint": 0,
            "key": -8,
            "name": "CopyApp",
            "description": "A simple APP that copies its inputs into its outputs. All inputs are copied into all outputs in the order they were declared in the graph. If an input is a container (e.g. a directory) it copies the content recursively.",
            "x": 452.7545908849069,
            "y": 466.65047797984175,
            "radius": 25,
            "collapsed": false,
            "subject": null,
            "expanded": true,
            "repositoryUrl": "https://github.com/ICRAR/daliuge",
            "commitHash": "b11f970",
            "paletteDownloadUrl": "https://raw.githubusercontent.com/ICRAR/EAGLE_test_repo/master/daliuge/daliuge-master.palette",
            "dataHash": "d3133e45e28a7944c18ee04f5631f49d1707d54764a385d35fc7d51defeeebfe",
            "fields": [
                {
                    "name": "bufsize",
                    "value": 65536,
                    "defaultValue": "65536",
                    "description": "Buffer size",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "f2308998-ecab-4da1-b565-851cd4547975",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "dropclass",
                    "value": "dlg.apps.simple.CopyApp",
                    "defaultValue": "dlg.apps.simple.CopyApp",
                    "description": "Application class",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "2cc9e27f-909d-4ea4-8714-34b4583477f8",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "execution_time",
                    "value": 5,
                    "defaultValue": "5",
                    "description": "Estimated execution time",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "8cf8f578-a8b1-428a-bf2d-723454a12ae9",
                    "parameterType": "ConstraintParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "num_cpus",
                    "value": 1,
                    "defaultValue": "1",
                    "description": "Number of cores used",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "6dc5bec1-973f-4b57-9f21-a10bb99bbc36",
                    "parameterType": "ConstraintParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "group_start",
                    "value": false,
                    "defaultValue": "False",
                    "description": "Is this node the start of a group?",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "c76a7bd6-7759-4f4b-a9f5-af556129210d",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "n_tries",
                    "value": 1,
                    "defaultValue": "1",
                    "description": "Specifies the number of times the 'run' method will be executed before finally giving up",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "e63169f6-8364-4bb2-a708-50dd9b77c292",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "dummy",
                    "value": "",
                    "defaultValue": "",
                    "description": "Dummy port",
                    "readonly": false,
                    "type": "Object",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "c95562ef-e8e1-49f7-9e58-a7c08bd61897",
                    "parameterType": "ApplicationArgument",
                    "usage": "InputOutput"
                },
                {
                    "name": "input_parser",
                    "value": "pickle",
                    "defaultValue": "pickle",
                    "description": "Input port parsing technique",
                    "readonly": false,
                    "type": "Select",
                    "precious": false,
                    "options": [
                        "raw",
                        "pickle",
                        "eval",
                        "npy",
                        "path",
                        "dataurl"
                    ],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "e96dc5a9-b0d3-448b-8035-a17522be1354",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "output_parser",
                    "value": "pickle",
                    "defaultValue": "pickle",
                    "description": "Output port parsing technique",
                    "readonly": false,
                    "type": "Select",
                    "precious": false,
                    "options": [
                        "raw",
                        "pickle",
                        "eval",
                        "npy",
                        "path",
                        "dataurl"
                    ],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "be08f0f4-459e-4bd9-a0fc-d39b8c9bb58a",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                }
            ],
            "inputAppFields": [],
            "outputAppFields": [],
            "inputApplicationName": "",
            "inputApplicationType": "None",
            "inputApplicationKey": null,
            "inputApplicationDescription": "",
            "outputApplicationName": "",
            "outputApplicationType": "None",
            "outputApplicationKey": null,
            "outputApplicationDescription": ""
        },
        {
            "category": "ParameterSet",
            "categoryType": "Data",
            "isGroup": false,
            "color": "#2c2c2c",
            "drawOrderHint": 0,
            "key": -10,
            "name": "DynamicParset",
            "description": "A set of parameters, which can be set and modified in EAGLE and thus is part of the graph. Multiple serialisation formats are available.",
            "x": 266.81464216358387,
            "y": 467.29212702426304,
            "radius": 25,
            "collapsed": false,
            "subject": null,
            "expanded": true,
            "repositoryUrl": "https://github.com/ICRAR/daliuge",
            "commitHash": "b11f970",
            "paletteDownloadUrl": "https://raw.githubusercontent.com/ICRAR/EAGLE_test_repo/master/daliuge/daliuge-master.palette",
            "dataHash": "057c6a8ea53a5d04ce07c2e26ef25cfca59504053407289c5309f81cc44556fc",
            "fields": [
                {
                    "name": "data_volume",
                    "value": 5,
                    "defaultValue": "5",
                    "description": "Estimated size of the data contained in this node",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "398a6500-2055-4660-9d1f-a727544537c5",
                    "parameterType": "ConstraintParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "group_end",
                    "value": false,
                    "defaultValue": "False",
                    "description": "Is this node the end of a group?",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "9e553582-b6f1-44cd-97c0-07a572f3672f",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "mode",
                    "value": "YANDA",
                    "defaultValue": "YANDA",
                    "description": "Serialisation method.",
                    "readonly": false,
                    "type": "Select",
                    "precious": false,
                    "options": [
                        "YANDA",
                        "ini",
                        "yaml",
                        "json",
                        "toml",
                        "pickle"
                    ],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "7a274e4b-79d8-45e4-9c49-774db337937f",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "config_data",
                    "value": "",
                    "defaultValue": "",
                    "description": "Additional configuration information to be mixed in with the initial data",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "94777a95-5f16-4266-9fcd-6f2dc3de2a40",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "dropclass",
                    "value": "dlg.data.drops.parset_drop.ParameterSetDROP",
                    "defaultValue": "dlg.data.drops.parset_drop.ParameterSetDROP",
                    "description": "Drop class",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "b714510d-9046-4d77-a0e2-3437fcb6af08",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "streaming",
                    "value": false,
                    "defaultValue": "False",
                    "description": "Specifies whether this data component streams input and output data",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "3380a15d-8223-45f2-968a-deefd93a04ce",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "persist",
                    "value": false,
                    "defaultValue": "False",
                    "description": "Specifies whether this data component contains data that should not be deleted after execution",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "b4f6f09a-b0b5-4992-9fc3-d6d02110fe25",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort"
                },
                {
                    "name": "Config",
                    "value": "",
                    "defaultValue": "",
                    "description": "The output configuration file",
                    "readonly": false,
                    "type": "Object.File",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "02125248-1dd6-4fd6-9b2b-4ed921c96e1d",
                    "parameterType": "ComponentParameter",
                    "usage": "OutputPort"
                },
                {
                    "name": "Cimager.dataset",
                    "value": "$DLG_ROOT/testdata/HIPASSJ2304-19_SB51759_F00_B16.ms",
                    "defaultValue": "",
                    "description": "Measurement set file name to read from. Usual substitution rules apply if the parameter is a single string. If the parameter is given as a vector of strings all measurement sets given by this vector are effectively concatenated together on-the-fly in the serial case. In the parallel case, the size of the vector is required to be either 1 or the number of nodes - 1, and therefore there is one measurement set per worker node.",
                    "readonly": false,
                    "type": "Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "18d1e7d9-2440-41df-80f0-09c36bb88682",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.Images.Names",
                    "value": "[image.HIPASSJ1922-54_SB51537_F00_B09]",
                    "defaultValue": "",
                    "description": "List of image names which this imager will produce. If more than one image is given, a superposition is assumed (i.e. visibilities are fitted with a combined effect of two images; two measurement equations are simply added). Parameters of each image defined in this list must be given in the same parset using ImageName.something keywords (with usual prefix). Note, all image names must start with word image (this is how parameters representing images are distinguished from other type of free parameters in ASKAPsoft), otherwise an exception is thrown. Example of valid names are: image.10uJy, image, imagecena.",
                    "readonly": false,
                    "type": "Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "df7622dc-d026-435d-9f31-700d32f13d78",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.Images.direction",
                    "value": "23:16:13.617000, -22.00.05.16000, J2000",
                    "defaultValue": "",
                    "description": "Direction to the centre of the required image (or tangent point for facets). This vector should contain a 3-element direction quantity containing right ascension, declination and epoch, e.g. [12h30m00.00, -45.00.00.00, J2000]. Note that a casa style of declination delimiters (dots rather than colons) is essential. Only J2000 directions are currently supported.",
                    "readonly": false,
                    "type": "Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "824b37a3-3c0b-4d03-b7e7-b1c13d0ee818",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.imagetype",
                    "value": "fits",
                    "defaultValue": "casa",
                    "description": "Type of the image handler (determines the format of the images, both which are written to or read from the disk). Either fits or casa can be requested.",
                    "readonly": false,
                    "type": "Select",
                    "precious": false,
                    "options": [
                        "fits",
                        "casa"
                    ],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "569d17aa-4c20-4cea-9810-b82ea924e04c",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.Images.shape",
                    "value": "",
                    "defaultValue": "384,384",
                    "description": "Optional parameter to define the default shape for all images. If an individualshapeparameter is specified separately for one of the images, this default value of the shape is overridden. Individualshapeparameters (see below) must be given for all images if this parameter is not defined. Must be a two-element vector. 1.7 * pb FWHM (~1st null) + 2 * max(pb offset)pb FWHM = 1.2*lambda/12",
                    "readonly": false,
                    "type": "Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "ab58c5a9-a2fd-4807-8a9a-d682a91e9db1",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.Images.cellsize",
                    "value": "",
                    "defaultValue": "2arcsec,2arcsec",
                    "description": "Optional parameter to define the default pixel (or cell) size for all images. If an individual cell size parameter is specified separately for one of the images, this default value is overridden. Individual cell size parameters (see below) must be given for all images, if this parameter is omitted. If defined, a 2-element quantity string vector is expected, e.g. [6.0arcsec, 6.0arcsec]. (1/max(u,v) / 6 rad)",
                    "readonly": false,
                    "type": "Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "08833923-bdbe-46e9-8212-b227ae07a226",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.freqframe",
                    "value": "",
                    "defaultValue": "topo",
                    "description": "Frequency frame to work in (the frame is converted when the dataset is read). Either lsrk or topo is supported.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "eba2651f-39c5-4b51-9085-e5a926e89b66",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.Images.writeAtMajorCycle",
                    "value": false,
                    "defaultValue": "false",
                    "description": "If true, the current images are written to disk after each major cycle (.cyclesuffix is added to the name to reflect which major cycle the image corresponds to). By default, the images are only written afterncyclesmajor cycles are completed.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "1419c359-8869-49bd-ac7b-2c7ee3056078",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.nUVWMachines",
                    "value": null,
                    "defaultValue": "0",
                    "description": "Size of uvw-machines cache. uvw-machines are used to convert uvw from a given phase centre to a common tangent point. To reduce the cost to set the machine up (calculation of the transformation matrix), a number of these machines is cached. The key to the cache is a pair of two directions: the current phase centre and the tangent centre. If the required pair is within the tolerances of that used to setup one of the machines in the cache, this machine is reused. If none of the cache items matches the least accessed one is replaced by the new machine which is set up with the new pair of directions. The code would work faster if this parameter is set to the number of phase centres encountered during imaging. In non-faceting case, the optimal setting would be the number of synthetic beams times the number of fields. For faceting (btw, the performance gain is quite significant in this case), it should be further multiplied by the number of facets. Direction tolerances are given as a separate parameter.",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "fe275aa1-cdc1-483c-892d-d34a5633ab21",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.ncycles",
                    "value": null,
                    "defaultValue": "0",
                    "description": "Number of major cycles (and iterations over the dataset)",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "88f89489-3e6e-468e-922a-2f91c2da58cb",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.snapshotimaging",
                    "value": false,
                    "defaultValue": "false",
                    "description": "If true, snapshot imaging is done. In this mode, a w=au+bv plane is fitted to baseline coordinates and the effective w-term becomes a difference between the actual w-term and the fitted plane. The subtraction of such a plane is equivalent to the coordinate distortion. Therefore, every time the fit is updated, the current dirty and weight images are regridded into a stable frame. How often the new fit is done depends on the w-tolerance parameter, which must be given if the snap-shot imaging is used.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "92ddabcf-3e4a-43e5-b8bd-64b95abae826",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.snapshotimaging.wtolerance",
                    "value": "",
                    "defaultValue": "",
                    "description": "Required tolerance on residual w-term for snap-shot imaging (in wavelengths).This parameter must be given if the snap-shot imaging is used. An exception is thrown if the antenna layout is significantly non-coplanar and the required tolerance cannot be achieved by plane fitting.",
                    "readonly": false,
                    "type": "Double",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "8aea39e2-e318-4678-9ecc-a3fe7e502192",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.snapshotimaging.longtrack",
                    "value": false,
                    "defaultValue": "false",
                    "description": "If true the best fit W plane for the snapshot is predicted by advancing the uvw in time and finding that plane which minimises the deviation in the future. Some minutes from the current time. This allows the max deviation to remain within tolerance for almost twice as long as the default scheme. This can have a substantial effect on processing time for long tracks. It should be a factor of two faster.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "3c2f3ef9-b349-46e0-b101-bfc8d0e00697",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.snapshotimaging.clipping",
                    "value": "",
                    "defaultValue": "0",
                    "description": "Optional clipping to avoid edge effects during image reprojection. This parameter represents the fraction of the image size (on each directional axis) which is zeroed (equally from both sides). It should be a non-negative number less than 1. Set it to 0 (default) to avoid any clipping. Applies to all images (image.*, residual.*, weights.*, etc.).",
                    "readonly": false,
                    "type": "Double",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "202cc16a-9546-4351-92da-8f90d9ef168b",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder",
                    "value": "Box",
                    "defaultValue": "",
                    "description": "Name of the gridder, further parameters are given bygridder.something. SeeGriddersfor details.",
                    "readonly": false,
                    "type": "Select",
                    "precious": false,
                    "options": [
                        "Box",
                        "SphFunc",
                        "WProject",
                        "MPIWProject",
                        "WStack",
                        "AWProject",
                        "AProjectWStack"
                    ],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "3b170f38-181b-4a0f-a330-433a5c185bd9",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.WProject.wmax",
                    "value": null,
                    "defaultValue": "largest w value relative to the tangent of the first image (or the largest residual w when using snapshots)",
                    "description": "Largest allowed absolute value of the w term in wavelengths.  An exception will be thrown if the dataset contains w-term exceeding this value (W scaling error: recommend allowing larger range of w).",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "e40a9ecb-ba0d-437b-a550-ddc62b2144d7",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.WProject.nwplanes",
                    "value": null,
                    "defaultValue": "65",
                    "description": "Number of w-planes. Number of w planes must be an odd positive number. For the WProject gridder this scales up the number of convolution functions calculated. For the WStack gridder this is the number of grids maintained. You may (and will) run out of memory for a large number of w planes, especially for the stacking algorithm",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "daca86a3-54e2-4ebb-b26f-0c13a44420c1",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.WProject.oversample",
                    "value": null,
                    "defaultValue": "8",
                    "description": "Oversampling factor. Convolution functions will be computed for this number of pixels per uv-cell.",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "0f77a81f-4732-4f88-8b36-0b0c85e6ea33",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.WProject.maxsupport",
                    "value": null,
                    "defaultValue": "256",
                    "description": "The largest allowed support size in pixels. The grid used to compute the convolution function (before the support is searched and the appropriate inner part of the grid is extracted) is initialised to have the size equal to the smallest of maxsupport and the image size. WProject uses maxsupport x maxsupport grid at the moment regardless of the image size.",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "168d80b0-d706-451d-983c-016551d1d7c7",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.WProject.variablesupport",
                    "value": false,
                    "defaultValue": "false",
                    "description": "If true, the support will be searched separately for each convolution function. This can speed things up considerably, unless costs to search the support dominates. It was also found that when variable support is used, the algorithm is more sensitive to cutoff value. Too high cutoff value has a significant impact on the image quality if the variable support is used.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "8d0476c4-9d8c-4376-9da1-a714047244a1",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.WProject.offsetsupport",
                    "value": false,
                    "defaultValue": "false",
                    "description": "If true, an offset of the convolution function will be treated separately (the support will be defined by size and offset, which can be non-zero in general). This option reduces the memory footprint and speeds up greeting. It can only be used in conjunction withvariablesupport=true",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "1a8f0660-4d43-42ef-b343-801fc71c57f7",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.gridder.WProject.sharecf",
                    "value": false,
                    "defaultValue": "false",
                    "description": "If true, use a (static) cache for the convolution functions in the WProject gridder. This saves both time and memory, especially for large images and spectral line cubes. Tests show no significant changes in continuum imaging but small differences in spectral cubes, it is not clear yet if these are a problem. Feedback welcome",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "c4b16bcd-016f-475b-bcdf-3fc41900a00d",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.Images.writeAtMajorCycle",
                    "value": false,
                    "defaultValue": "false",
                    "description": "If true, the current images are written to disk after each major cycle (.cyclesuffix is added to the name to reflect which major cycle the image corresponds to). By default, the images are only written afterncyclesmajor cycles are completed.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "03affa0a-11a2-4c89-9599-979c63658dd0",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver",
                    "value": "",
                    "defaultValue": "",
                    "description": "Name of the solver, further parameters are given bysolver.something. See Solvers for details",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [
                        "Clean",
                        "Dirty"
                    ],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "135dc147-db6d-41a5-888c-7c5325353e8d",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.algorithm",
                    "value": "",
                    "defaultValue": "BasisfunctionMFS",
                    "description": "Valid choices are MultiScale, Basisfunction, Hogbom, MultiScaleMFS and BasisfunctionMFS. Use Hogbom for a single scale, non-MFS case. For the Clean solver, the casacore\u2019sLatticeCleanerused to do the actual work in non-MSMFS case will be set up withCleanEnums::HOGBOMif algorithm is Hogbom and the single scale of 0 will be used.  For the Basisfunction algorithm, a re-implemented and improved version of the CASA MultiScale algorithm is used. BasisfunctionMFS is the optimised algorithm used for most ASKAP processing",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "89de8969-1642-46ba-871e-f9276b02a744",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.niter",
                    "value": null,
                    "defaultValue": "100",
                    "description": "Number of minor cycles",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "3f51c0ee-2491-47f0-b1d3-2543f53002c2",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.gain",
                    "value": null,
                    "defaultValue": "0.7",
                    "description": "Loop gain. Fraction of the peak subtracted during one minor cycle.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "81f6c89f-4460-493a-b0b4-ce25a97d1938",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.scales",
                    "value": "",
                    "defaultValue": "0,3,10",
                    "description": "Scales to be solved (defined in pixels). Ignored if algorithm=Hogbom",
                    "readonly": false,
                    "type": "Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "f4d2de68-e58f-436f-bbd9-4b1efcc9afce",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.verbose",
                    "value": "",
                    "defaultValue": "true",
                    "description": "True enables lots of output",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "118f265f-303b-4650-a471-f751a09b0476",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.tolerance",
                    "value": null,
                    "defaultValue": "0.1",
                    "description": "cutoff value given as a fraction of the largest diagonal element. The linear system describing interferometric measurement is inverted approximately, assuming that the matrix is diagonal, i.e. the right-hand side is divided by the appropriate diagonal element (which is a weight). If diagonal is smaller than this tolerance multiplied by the largest diagonal element, the right-hand side instead is either divided by the largest diagonal element to get the result or the result is set to zero. This is controlled byweightcutoffparameter. For images it means that areas with low weight (i.e. a mosaic edge) are not boosted up. In addition to weight truncation, all pixels with the weight below cutoff are normally masked out. Theweightcutoff.cleanparameter allows to assign mask corresponding to weight truncation. This allows S/N-based cleaning to happen, if the peak of S/N is realised outside the nominal field of view.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "05710dbe-8f12-40dc-ba06-91e4db3e6614",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.weightcutoff",
                    "value": "",
                    "defaultValue": "truncate",
                    "description": "Either zero or truncate. This parameter controls what actually happens for values below cutoff defined by thetoleranceparameter. Ifzerois given, the appropriate values are set to zero. Fortruncate, the values are divided by the largest diagonal.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "fbff03b2-40f2-466e-bee1-602f09a9e3a5",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.weightcutoff.clean",
                    "value": false,
                    "defaultValue": "false",
                    "description": "This parameter defines whether the values below cutoff are masked out or not. By default, the are masked out and so S/N-based clean never finds optima among these values. If this parameter is true, the mask is actually sqrt(tolerance), which corresponds to truncation of the diagonal during normalisation. This potentially allows cleaning to happen, if no peak of the S/N is realised among these values.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "509062de-bc33-4ed8-9cb3-8d733df480f9",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.decoupled",
                    "value": false,
                    "defaultValue": "true",
                    "description": "Use decoupled residuals - this improves convergence for large scales, allows the use of a lower percentage threshold.minorcycle and seems to have few drawbacks",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "e98dbfc1-a8dc-41a0-a5d1-5d9fd1b83346",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.psfwidth",
                    "value": null,
                    "defaultValue": "0",
                    "description": "Sets the width of the psf patch used in the minor cycle. This decreases memory use and run time by approximately the ratio of pixels in the patch to pixels in the image.",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "4f033de6-de0f-426f-a42a-c7bc607a7f15",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.logevery",
                    "value": null,
                    "defaultValue": "1",
                    "description": "How frequently to log progress in the minor cycle. Every nth iteration is reported (ie. iflogevery=100, every 100th iteration is reported), providing the iteration number, the peak residual, the objective function and the total flux.",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "53c6b079-2adf-4dc1-b82c-c14baaa1679f",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.detectdivergence",
                    "value": false,
                    "defaultValue": "true",
                    "description": "Check if the deconvolution is diverging - stop the major cycles if the residuals increase by a factor 2",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "a32699d4-70b4-46f9-a388-ca74643df1bd",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.threshold.minorcycle",
                    "value": "",
                    "defaultValue": "no threshold",
                    "description": "If defined, the parameter can be either a single string or a vector of 2 or 3 strings. A number without units, or with a percentage sign, is interpreted as a fractional stopping threshold (with respect to the peak residual). An absolute flux given in Jy or related units is interpreted as an absolute threshold. A string like 5.0sigma will set a threshold relative to the noise in the residuals. You can mix fractional and absolute or noise thresholds, but can\u2019t mix absolute and noise ones. An undefined parameter means no minor cycle thresholding is done. A second absolute flux (or noise) threshold can be used to specify a deep clean threshold. During deep cleaning only pixels already in the model are searched to find new components. Setting the deep clean threshold to 0.5 times the noise level generally leaves very few sidelobes visible. Deep clean and noise based threshold are currently only implemented for the BasisFunctionMFS solver",
                    "readonly": false,
                    "type": "Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "faf9c8b7-a390-4e72-a31f-d6c8af7216ae",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.threshold.majorcycle",
                    "value": "",
                    "defaultValue": "-1Jy",
                    "description": "The target peak residual. Use negative value to ensure all requested major cycles are done.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "6c621495-636c-4513-8273-9e6a9dcc11ae",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.preconditioner.GaussianTaper",
                    "value": "",
                    "defaultValue": "",
                    "description": "A Gaussian taper is applied to the visibilities. The parameter should be either a single string with the FWHM of a circular gaussian taper, or a vector of three strings for an elliptical taper: the major and minor axis FWHM and the position angle. String values may contain units, e.g.[10arcsec,10arcsec,34deg]. If no units are given, radians are assumed.GaussianTapercurrently conflicts with different uv-cell sizes for different images. An exception is thrown if such a condition exists.",
                    "readonly": false,
                    "type": "Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "69ec23ca-5205-4bb6-839a-bc496485e65e",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.preconditioner.GaussianTaper.isPsfSize",
                    "value": false,
                    "defaultValue": "false",
                    "description": "If true, try to make the final fitted PSF the size given. This uses the restore.beam.cutoff parameter for the fit. A warning will appear in the log if the target PSF size was not achieved.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "49e47a54-8d16-4bd9-975e-50a8b78aaaad",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.preconditioner.GaussianTaper.tolerance",
                    "value": null,
                    "defaultValue": "0.005",
                    "description": "Specify the fractional tolerance of the fitted beam size when isPsfSize is true, default is 0.5%",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "2f21ef19-bdfb-4c3c-9f06-7c52f2d98ceb",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.preconditioner.preservecf",
                    "value": false,
                    "defaultValue": "false",
                    "description": "Use a modified PSF to generate any preconditioner that is derived from the uv sampling function (e.g.WienerandRobust). This option takes a running mean over an approximate nearest-neighbour sampling function with a box width that is proportional to the support size of the gridding kernels. This enables post-gridding density weighting while preserving the gridding convolutions. Note that this is currently only used with theWienerpreconditioner and theWProjectgridder. The default is normally false, but will be true if preconditioning is used.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "f3a13f91-9207-4e1d-b360-b0b48a07208f",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.preconditioner.Wiener.robustness",
                    "value": null,
                    "defaultValue": "",
                    "description": "The noise power is derived from the given value of robustness to have roughly the same effect as the analogous parameter in Robust (i.e., -2.0 close to uniform weighting, +2.0 close to natural weighting). Note that the Wiener filter must be specified with eithernoisepowerorrobustness.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "20238afb-ceff-4dc7-b27c-51f3528501cd",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.restore",
                    "value": false,
                    "defaultValue": "false",
                    "description": "If true, the image will be restored (by convolving with the given 2D gaussian). This is an additional step to normal imaging, which, by default, ends with just a model image. The restored image is written into a separate image file (with the.restoredsuffix). The convolution is done with the restore solver (see alsoSolvers) which by default reuses the same parameters used to setup the image solver. An additional preconditioning step with alternative parameters can be specified usingrestore.preconditioner.xxx, which results in a second set of restored files (with the.alt.restoredsuffix). The only additional parameter of the restore solver is the shape of the gaussian representing clean beam (or flag to determine the shape). It is given by therestore.beamparameter, which must be present ifrestoreis set to True.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "c6757157-bdb7-4dd4-ad2e-0bb625d27baf",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.restore.beam",
                    "value": "",
                    "defaultValue": "",
                    "description": "Either a single wordfitor a quantity string describing the shape of the clean beam (to convolve the model image with). If quantity is given it must have exactly 3 elements, e.g. [30arcsec, 10arcsec, 40deg]. Otherwise an exception is thrown. This parameter is only used ifrestoreis set to True. If restore.beam=fit, the code will fit a 2D gaussian to the PSF image (first encountered if multiple images are solved for) and use the results of this fit.",
                    "readonly": false,
                    "type": "Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "c9abb0b5-4ca3-4376-be25-8237d7af81b8",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.restore.beam.cutoff",
                    "value": null,
                    "defaultValue": "0.05",
                    "description": "Cutoff for the support search prior to beam fitting, as a fraction of the PSF peak. This parameter is only used ifrestore.beam=fit. The code does fitting on a limited support (to speed things up and to avoid sidelobes influencing the fit). The extent of this support is controlled by this parameter representing the level of the PSF which should be included into support. This value should be above the first sidelobe level for meaningful results.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "f0cf052e-b1b3-4bf3-a14d-3a05b5a6d591",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.MaxUV",
                    "value": null,
                    "defaultValue": "",
                    "description": "Select data based on the uv-distance (in metres). Only visibility points corresponding to uv-distance smaller than the given value (defined in metres) are read from the measurement set. Note, the selection is done without taking frequency information into account.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "4f33d258-202e-4360-aba0-47e740249103",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.MinUV",
                    "value": null,
                    "defaultValue": "",
                    "description": "Select data based on the uv-distance (in metres). Only visibility points corresponding to uv-distance greater than the given value (defined in metres) are read from the measurement set. Note, the selection is done without taking frequency information into account.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "512bc555-def1-458e-8066-ca317db9105a",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.preconditioner.Names",
                    "value": "",
                    "defaultValue": "",
                    "description": "List of preconditioners to be applied (in the order they are given in the list). Preconditioners are ASKAPsoft equivalents of visibility weighting (i.e. uniform, robust, natural), which do not require multiple passes over the dataset. Preconditioners can be viewed as operators applied to equation matrix before it is solved. Having the normal matrix as close to the diagonal as possible (a diagonal form is actually assumed during the inversion process) makes the inversion more accurate. By default, no transformation to the normal matrix is done. This is equivalent to the natural weighting. The following preconditioners are currently implemented: Wiener, NormWiener, Robust and GaussianTaper. In addition, the word None is understood as an empty preconditioner which does nothing. Each preconditioner requires a specific set of parameters described in a separate section. These parameters are given after the name of the preconditioner, e.g. preconditioner.Wiener.noisepower (see below)",
                    "readonly": false,
                    "type": "Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "c0b54055-8b1e-45b2-8cf0-596dfa5e692a",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.nchanpercore",
                    "value": null,
                    "defaultValue": "1",
                    "description": "",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "1d5a3220-3353-4b8a-8a26-a7dfa391d09f",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.nwriters",
                    "value": null,
                    "defaultValue": "1",
                    "description": "The number of output cubes to generate in spectral cube mode.",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "f18282f8-f17f-450b-aff6-ba4dfc8b5edc",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.singleoutputfile",
                    "value": false,
                    "defaultValue": "false",
                    "description": "Single output cube. Useful in the case of multiple writers.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "0d64ab2f-466e-41c8-a431-df2718d21509",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.Channels",
                    "value": "",
                    "defaultValue": "",
                    "description": "Channels to be selected from the measurement set. Syntax is [<number>,<start>]. Defaults to all the channels.",
                    "readonly": false,
                    "type": "Array",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "8e3cd7fe-aa0a-4099-9ce0-41c8345ede08",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.usetmpfs",
                    "value": false,
                    "defaultValue": "false",
                    "description": "Whether to store the visibilities in shared memory.This will give a performance boost at the expense of memory usage. Better used for processing continuum data.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "f93c3865-a7c5-46f9-bb7a-054a34835078",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.tmpfs",
                    "value": "",
                    "defaultValue": "/dev/shm",
                    "description": "Location of the shared memory.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "703f3178-5996-4697-ac43-bd6e2de94bca",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.solver.Clean.solutiontype",
                    "value": "MAXBASE",
                    "defaultValue": "MAXBASE",
                    "description": "The type of peak finding algorithm to use in the deconvolution. Choices are MAXCHISQ, MAXTERM0, or MAXBASE.",
                    "readonly": false,
                    "type": "Select",
                    "precious": false,
                    "options": [
                        "MAXBASE",
                        "MAXCHISQ",
                        "MAXTERM0"
                    ],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "de283698-c8e5-4850-83f6-c5a5e3efac8a",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.restore.beamReference",
                    "value": "",
                    "defaultValue": "mid",
                    "description": "The channel to use as the reference for the beam - this channel\u2019s beam is written to the cube header. Values can be an integer indicating the channel number (0-based), or one of \u2018mid\u2019, \u2018first\u2019, or \u2018last\u2019.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "1f9d26bc-4d40-4058-bc2f-81f3fd149fd5",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                },
                {
                    "name": "Cimager.Images.restFrequency",
                    "value": "",
                    "defaultValue": "null",
                    "description": "A string indicating the rest frequency to be written to the image cube header (for the restored, model and residual cubes only). The string can be a quantity string (e.g. 1234.567MHz) or the special string \u2018HI\u2019, which resovles to 1420.405751786 MHz. If not given, no rest frequency is written to the cubes.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false,
                    "keyAttribute": false,
                    "id": "a92a146b-981a-4bd1-b946-b3c9a6041c8c",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort"
                }
            ],
            "inputAppFields": [],
            "outputAppFields": [],
            "inputApplicationName": "",
            "inputApplicationType": "None",
            "inputApplicationKey": null,
            "inputApplicationDescription": "",
            "outputApplicationName": "",
            "outputApplicationType": "None",
            "outputApplicationKey": null,
            "outputApplicationDescription": ""
        }
    ],
    "linkDataArray": [
        {
            "from": -1,
            "fromPort": "58a4503f-a894-4f9c-ab7a-3b14896a8b3b",
            "to": -2,
            "toPort": "da3f2498-cd24-451f-8336-1724d9300606",
            "dataType": "Object.File",
            "loop_aware": "0",
            "closesLoop": false
        },
        {
            "from": -2,
            "fromPort": "da3f2498-cd24-451f-8336-1724d9300606",
            "to": -4,
            "toPort": "8528f8ab-2dbb-4b4d-87c9-6667e732c13e",
            "dataType": "Object",
            "loop_aware": "0",
            "closesLoop": false
        },
        {
            "from": -8,
            "fromPort": "c95562ef-e8e1-49f7-9e58-a7c08bd61897",
            "to": -6,
            "toPort": "d02e24bd-4049-4afc-a8cc-0485f19d5373",
            "dataType": "Object",
            "loop_aware": "0",
            "closesLoop": false
        },
        {
            "from": -10,
            "fromPort": "02125248-1dd6-4fd6-9b2b-4ed921c96e1d",
            "to": -8,
            "toPort": "c95562ef-e8e1-49f7-9e58-a7c08bd61897",
            "dataType": "Object.File",
            "loop_aware": "0",
            "closesLoop": false
        }
    ]
}